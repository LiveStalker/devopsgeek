---
title: Как вернуть массив из C-функции.
tags: c-lang
---
Про то, как вернуть массив из функции на языке C, написано достаточно много статей. Все же мне бы хотелось обобщить техники, с помощью, которых это можно сделать.

Давайте для примера разработаем функцию, которая будет конвертировать число в строковое представление (эта функция будет обратная функции atoi), назовем её itoa. Как она должна возвращать сгенерированную (строку) последовательность цифр?

В этой заметке рассмотрим три техники. 

> Для простоты примера не будем реализовывать цикл do/while, а просто воспользуемся функцией sprintf. Вызов этой функции настолько прост, что большинство C программ используют его непосредственно, поэтому, наверное и нет стандартной функции itoa.

Давайте, посмотрим на вариант, который _не_ будет работать, поэтому не пишите такой код.

```c
char *itoa(int n)
{
    char retbuf[25];
    sprintf(retbuf, "%d", n);
    return retbuf;
}
```

На первый взгляд реализация выглядит вполне разумной (в _некоторых_ случаях, этот код будет работать правильно). Тем не менее, этот код содержит серьезную ошибку, посмотрите на переменную retbuf – это локальная переменная. Так как, это обычная локальная переменная функции, она имеет автоматическую длительность хранения.

> Идентификатор с автоматической длительностью хранения ("локальный идентификатор") имеет выделенную память и определенное значение только внутри блока, в котором он определен или объявлен. Автоматическому идентификатору выделяется новая память при каждом входе программы в соответствующий блок; при выходе программы из этого блока память (и значение) идентификатора освобождается.

Таким образом, указатель на массив, который возвращает функция itoa уже не будет существовать, когда вызывающий код получит значение. (Оператор return retbuf; возвращает указатель на первый элемент массива retbuf. В следствии эквивалентности массивов и указателей retbuf равносильно &retbuf[0]). Когда вызывающий код попытается использовать указатель на созданную функцией itoa строку, он может быть все ещё валидный, либо память может уже использоваться другой функцией. Вот почему первая версия нашей функции itoa не правильная. Функция никогда не должна возвращать указатель на локальные переменные с автоматическим временем жизни.
